# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `http-2` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module HTTP2; end

class HTTP2::Buffer
  extend ::Forwardable

  def initialize(str = T.unsafe(nil)); end

  def +(other); end
  def <<(string); end
  def ==(other); end
  def [](*args, &block); end
  def []=(*args, &block); end
  def bytesize(*args, &block); end
  def each_byte(*args, &block); end
  def empty?(*args, &block); end
  def encoding(*args, &block); end
  def force_encoding(*args); end
  def getbyte; end
  def include?(*args, &block); end
  def inspect(*args, &block); end
  def length(*args, &block); end
  def ord(*args, &block); end
  def prepend(string); end
  def read(n); end
  def read_uint32; end
  def readbyte(n); end
  def setbyte(*args, &block); end
  def size(*args, &block); end
  def slice(*args); end
  def slice!(*args); end
  def to_s(*args, &block); end
  def to_str(*args, &block); end
  def unpack(*args, &block); end
end

HTTP2::Buffer::UINT32 = T.let(T.unsafe(nil), String)
HTTP2::CONNECTION_PREFACE_MAGIC = T.let(T.unsafe(nil), String)

class HTTP2::Client < ::HTTP2::Connection
  def initialize(**settings); end

  def receive(frame); end
  def send(frame); end
  def send_connection_preface; end
  def upgrade; end

  class << self
    def settings_header(**settings); end
  end
end

class HTTP2::Connection
  include ::HTTP2::FlowBuffer
  include ::HTTP2::Emitter
  include ::HTTP2::Error

  def initialize(**settings); end

  def <<(*args); end
  def active_stream_count; end
  def closed?; end
  def goaway(error = T.unsafe(nil), payload = T.unsafe(nil)); end
  def local_settings; end
  def local_window; end
  def new_stream(**args); end
  def pending_settings; end
  def ping(payload, &blk); end
  def receive(data); end
  def remote_settings; end
  def remote_window; end
  def settings(payload); end
  def state; end
  def window; end
  def window_update(increment); end

  private

  def activate_stream(id: T.unsafe(nil), **args); end
  def cleanup_recently_closed; end
  def connection_error(error = T.unsafe(nil), msg: T.unsafe(nil), e: T.unsafe(nil)); end
  def connection_frame?(frame); end
  def connection_management(frame); end
  def connection_settings(frame); end
  def decode_headers(frame); end
  def encode(frame); end
  def encode_headers(frame); end
  def error(error = T.unsafe(nil), msg: T.unsafe(nil), e: T.unsafe(nil)); end
  def manage_state(_); end
  def send(frame); end
  def validate_settings(role, settings); end
end

HTTP2::DEFAULT_CONNECTION_SETTINGS = T.let(T.unsafe(nil), Hash)
HTTP2::DEFAULT_FLOW_WINDOW = T.let(T.unsafe(nil), Integer)
HTTP2::DEFAULT_HEADER_SIZE = T.let(T.unsafe(nil), Integer)
HTTP2::DEFAULT_MAX_CONCURRENT_STREAMS = T.let(T.unsafe(nil), Integer)
HTTP2::DEFAULT_WEIGHT = T.let(T.unsafe(nil), Integer)

module HTTP2::Emitter
  def add_listener(event, &block); end
  def emit(event, *args, &block); end
  def on(event, &block); end
  def once(event, &block); end

  private

  def listeners(event); end
end

module HTTP2::Error; end
class HTTP2::Error::CompressionError < ::HTTP2::Error::ProtocolError; end
class HTTP2::Error::ConnectionClosed < ::HTTP2::Error::Error; end
class HTTP2::Error::Error < ::StandardError; end
class HTTP2::Error::FlowControlError < ::HTTP2::Error::ProtocolError; end
class HTTP2::Error::HandshakeError < ::HTTP2::Error::Error; end
class HTTP2::Error::InternalError < ::HTTP2::Error::ProtocolError; end
class HTTP2::Error::ProtocolError < ::HTTP2::Error::Error; end
class HTTP2::Error::StreamClosed < ::HTTP2::Error::Error; end
class HTTP2::Error::StreamLimitExceeded < ::HTTP2::Error::Error; end

module HTTP2::FlowBuffer
  def buffered_amount; end

  private

  def calculate_window_update(window_max_size); end
  def process_window_update(frame); end
  def send_data(frame = T.unsafe(nil), encode = T.unsafe(nil)); end
  def update_local_window(frame); end
end

class HTTP2::Framer
  include ::HTTP2::Error

  def initialize; end

  def common_header(frame); end
  def generate(frame); end
  def max_frame_size; end
  def max_frame_size=(_arg0); end
  def parse(buf); end
  def read_common_header(buf); end

  private

  def pack_error(e); end
  def unpack_error(e); end
end

HTTP2::Framer::DEFAULT_MAX_FRAME_SIZE = T.let(T.unsafe(nil), Integer)
HTTP2::Framer::DEFINED_ERRORS = T.let(T.unsafe(nil), Hash)
HTTP2::Framer::DEFINED_SETTINGS = T.let(T.unsafe(nil), Hash)
HTTP2::Framer::EBIT = T.let(T.unsafe(nil), Integer)
HTTP2::Framer::FRAME_FLAGS = T.let(T.unsafe(nil), Hash)
HTTP2::Framer::FRAME_LENGTH_HISHIFT = T.let(T.unsafe(nil), Integer)
HTTP2::Framer::FRAME_LENGTH_LOMASK = T.let(T.unsafe(nil), Integer)
HTTP2::Framer::FRAME_TYPES = T.let(T.unsafe(nil), Hash)
HTTP2::Framer::FRAME_TYPES_WITH_PADDING = T.let(T.unsafe(nil), Array)
HTTP2::Framer::HEADERPACK = T.let(T.unsafe(nil), String)
HTTP2::Framer::MAX_STREAM_ID = T.let(T.unsafe(nil), Integer)
HTTP2::Framer::MAX_WINDOWINC = T.let(T.unsafe(nil), Integer)
HTTP2::Framer::RBIT = T.let(T.unsafe(nil), Integer)
HTTP2::Framer::RBYTE = T.let(T.unsafe(nil), Integer)
HTTP2::Framer::UINT16 = T.let(T.unsafe(nil), String)
HTTP2::Framer::UINT32 = T.let(T.unsafe(nil), String)
HTTP2::Framer::UINT8 = T.let(T.unsafe(nil), String)
module HTTP2::Header; end

class HTTP2::Header::Compressor
  def initialize(**options); end

  def encode(headers); end
  def header(h, buffer = T.unsafe(nil)); end
  def integer(i, n); end
  def string(str); end
  def table_size=(size); end
end

class HTTP2::Header::Decompressor
  def initialize(**options); end

  def decode(buf); end
  def header(buf); end
  def integer(buf, n); end
  def string(buf); end
  def table_size=(size); end
end

class HTTP2::Header::EncodingContext
  include ::HTTP2::Error

  def initialize(**options); end

  def addcmd(*header); end
  def current_table_size; end
  def dereference(index); end
  def dup; end
  def encode(headers); end
  def options; end
  def process(cmd); end
  def table; end
  def table_size=(size); end

  private

  def add_to_table(cmd); end
  def size_check(cmd); end
end

HTTP2::Header::EncodingContext::STATIC_TABLE = T.let(T.unsafe(nil), Array)
HTTP2::Header::HEADREP = T.let(T.unsafe(nil), Hash)

class HTTP2::Header::Huffman
  include ::HTTP2::Error

  def decode(buf); end
  def encode(str); end
end

HTTP2::Header::Huffman::BITS_AT_ONCE = T.let(T.unsafe(nil), Integer)
HTTP2::Header::Huffman::CODES = T.let(T.unsafe(nil), Array)
HTTP2::Header::Huffman::ENCODE_TABLE = T.let(T.unsafe(nil), Array)
HTTP2::Header::Huffman::EOS = T.let(T.unsafe(nil), Integer)
HTTP2::Header::Huffman::MACHINE = T.let(T.unsafe(nil), Array)
HTTP2::Header::Huffman::MAX_FINAL_STATE = T.let(T.unsafe(nil), Integer)
HTTP2::Header::LINEAR = T.let(T.unsafe(nil), Hash)
HTTP2::Header::LINEARH = T.let(T.unsafe(nil), Hash)
HTTP2::Header::NAIVE = T.let(T.unsafe(nil), Hash)
HTTP2::Header::NAIVEH = T.let(T.unsafe(nil), Hash)
HTTP2::Header::SHORTER = T.let(T.unsafe(nil), Hash)
HTTP2::Header::SHORTERH = T.let(T.unsafe(nil), Hash)
HTTP2::Header::STATIC = T.let(T.unsafe(nil), Hash)
HTTP2::Header::STATICH = T.let(T.unsafe(nil), Hash)
HTTP2::RECENTLY_CLOSED_STREAMS_TTL = T.let(T.unsafe(nil), Integer)
HTTP2::SPEC_DEFAULT_CONNECTION_SETTINGS = T.let(T.unsafe(nil), Hash)

class HTTP2::Server < ::HTTP2::Connection
  def initialize(**settings); end

  def upgrade(settings, headers, body); end

  private

  def promise(*args, &callback); end
end

class HTTP2::Stream
  include ::HTTP2::FlowBuffer
  include ::HTTP2::Emitter
  include ::HTTP2::Error

  def initialize(connection:, id:, weight: T.unsafe(nil), dependency: T.unsafe(nil), exclusive: T.unsafe(nil), parent: T.unsafe(nil), state: T.unsafe(nil)); end

  def <<(frame); end
  def cancel; end
  def chunk_data(payload, max_size); end
  def close(error = T.unsafe(nil)); end
  def closed; end
  def closed?; end
  def data(payload, end_stream: T.unsafe(nil)); end
  def dependency; end
  def headers(headers, end_headers: T.unsafe(nil), end_stream: T.unsafe(nil)); end
  def id; end
  def local_window; end
  def parent; end
  def promise(headers, end_headers: T.unsafe(nil), &block); end
  def receive(frame); end
  def refuse; end
  def remote_window; end
  def reprioritize(weight: T.unsafe(nil), dependency: T.unsafe(nil), exclusive: T.unsafe(nil)); end
  def send(frame); end
  def state; end
  def weight; end
  def window; end
  def window_update(increment); end

  private

  def complete_transition(frame); end
  def end_stream?(frame); end
  def error(error = T.unsafe(nil), msg: T.unsafe(nil)); end
  def event(newstate); end
  def manage_state(frame); end
  def process_priority(frame); end
  def stream_error(error = T.unsafe(nil), msg: T.unsafe(nil)); end
  def transition(frame, sending); end
end

HTTP2::VERSION = T.let(T.unsafe(nil), String)
